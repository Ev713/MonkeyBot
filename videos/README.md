# üêí MonkeyBot: Adhesion-Free Wall Climbing Framework

| Status | Language | License |
| :--- | :--- | :--- |
| **Active Development** | Python (100%) | *Unspecified (Contact Authors)* |

## üí° Project Overview

**MonkeyBot** is a simulation and planning framework for a **multi-legged wall-climbing robot** that operates without relying on any adhesive mechanisms (magnets, suction, or microspines).

In contrast to most wall-climbing robotics, MonkeyBot tackles the challenge of **sparse, discrete, and spatially constrained gripping points**‚Äîa scenario common in human or natural climbing. The system models the climbing process as a **numeric planning problem** that integrates discrete grip selection with complex, continuous body motions, such as dynamic jumps.

The project combines a custom 2D physics-based simulation with advanced planning techniques to achieve physically plausible and robust climbing strategies.

---

## ‚öôÔ∏è Core Technical Framework

The framework is built on a custom adaptation of the $\text{SAS}^+$ planning model, focusing on the following key components:

### 1. The Planning Problem

The state of the robot is defined by its center position ($c$) and the positions of its $n$ feet ($f^i$) on a set of predefined admissible gripping points ($\mathcal{GP}$). The planning engine seeks a sequence of actions to move the body center from an initial state ($s_0$) to a goal position ($g$).

### 2. Action Hierarchy

The system uses a two-tiered action hierarchy:

* **Primitive Actions (Kinematic):**
    * **Move Foot ($mf^i_p$):** Detaches and re-attaches one foot to a new, reachable grip $p$.
    * **Move Center ($mc_\delta$):** Shifts the body center to an adjacent grid cell $\delta$, maintaining kinematic reachability for all attached feet.
* **Complex Actions (Dynamic):**
    * **Transition Links ($U_t$):** Precomputed dynamic maneuvers, specifically **Jumps**, that allow for rapid, non-kinematic transitions between stable configurations. 

### 3. Transition Links and Precomputation

To manage the complexity of dynamic actions, the framework introduces **Transition Links ($TL$)**.

* A complex, dynamically-constrained precondition ($P$) is replaced by a simple check against a **State Summary Function ($H$)**.
* **Offline Precomputation** searches for valid dynamic jump trajectories that satisfy time-based constraints (e.g., minimum **Takeoff Phase** time to ensure propulsion, and minimum **Landing/Grip Phase** time to establish new grips).
* The precomputed links $\langle H_i, s_f \rangle$ are added to the planning problem as action variables, greatly increasing the efficiency of the high-level planner by offloading the physics check.

---

## üíª Repository Structure

The project is structured to separate core logic, simulation data, and analysis tools:

| Directory/File | Description |
| :--- | :--- |
| **`monkey_bot/`** | Contains the **core code** for the MonkeyBot agent, simulator logic, and control signal interfaces. |
| **`instances/`** | Stores generated simulation input files and **climbing scenarios**. |
| **`plans/`** | Stores the output motion plans and paths generated by the bot. |
| **`tests/`** | Contains unit and integration tests. |
| **`instance_generator.py`** | Utility script to generate new simulation input files. |
| **`angle_data_analyzer.py`** | Script for analyzing metrics related to joint angles and movement paths. |
| **`pruning_analyzer.py`** | Script for analyzing algorithmic efficiency metrics related to search space pruning. |
| **`*.mp4`** | Example videos (`Mixed.mp4`, `Random.mp4`, etc.) illustrating simulation results. |
| **`*_metrics.csv`** | Raw metric data for computational analysis. |

---

## üöÄ Installation

### Prerequisites
You must have **Python 3.x** installed. The project uses standard scientific and simulation libraries.

### Steps

1.  **Clone the repository:**
    ```bash
    git clone [https://github.com/Ev713/MonkeyBot.git](https://github.com/Ev713/MonkeyBot.git)
    cd MonkeyBot
    ```

2.  **Set up the environment:**
    The simulation environment is built atop **Pygame** and **Pymunk**. Standard data analysis libraries are also required.

    ```bash
    # Create a virtual environment
    python3 -m venv venv
    source venv/bin/activate

    # Install necessary dependencies
    pip install pygame pymunk numpy pandas
    ```
    *Note: A complete `requirements.txt` is recommended for future releases.*

---

## üî¨ Usage and Execution

### 1. Generating a Scenario
Generate a new set of gripping points or a simulation instance:
```bash
python instance_generator.py


## üî¨ Usage and Execution

### Running a Simulation

The primary entry point for running MonkeyBot simulations is through the `test_sim_runner` module.

#### Basic Execution

1. **Navigate to the test runner directory:**
   ```bash
   cd test_sim_runner
   ```

2. **Run the simulation:**
   ```bash
   python test_sim_runner.py
   ```

#### Function Parameters

The `test_sim_runner()` function accepts the following arguments:

| Parameter | Type | Description |
|-----------|------|-------------|
| `instance_folder` | `str` | Path to the folder containing scenario instances (e.g., `"../instances/"`) |
| `instance_name` | `str` | Name of the specific instance file to load (e.g., `"climbing_scenario_01"`) |
| `simulator_config` | `dict` | Configuration dictionary for the physics simulator (timestep, gravity, etc.) |
| `robot_config` | `dict` | Configuration dictionary for the robot parameters (body dimensions, foot count, etc.) |

#### Example Usage

```python
from test_sim_runner import test_sim_runner

# Define configurations
simulator_config = {
    'timestep': 0.01,
    'gravity': (0, -981),  # cm/s^2
    'damping': 0.9
}

robot_config = {
    'num_feet': 4,
    'body_mass': 5.0,
    'foot_reach': 50.0
}

# Run simulation
test_sim_runner(
    instance_folder="../instances/",
    instance_name="scenario_wall_01",
    simulator_config=simulator_config,
    robot_config=robot_config
)
```

#### Execution Pipeline

When you run `test_sim_runner()`, the following process occurs:

1. **Initialization:**
   - The `SimulationRunner` is created with the provided configurations
   - Instance data (gripping points, initial state, goal state) is loaded from the specified folder

2. **Robot Controller Setup:**
   - The `RobotController` component initializes the planning engine
   - A high-level plan is computed using the action hierarchy (primitive and complex actions)
   - The plan consists of a sequence of actions to reach the goal state

3. **Action Translation:**
   - Each planned action is transformed into a set of **control procedures**
   - Procedures include:
     - Kinematic movements (foot repositioning, center shifts)
     - Dynamic maneuvers (jumps using precomputed transition links)
     - Force profiles and timing constraints

4. **Simulation Execution:**
   - The `Simulator` executes each procedure step-by-step
   - Physics integration using Pymunk handles collision detection and dynamics
   - Visual rendering through Pygame displays the climbing motion in real-time

5. **Output:**
   - The generated plan is saved to the `plans/` directory
   - Simulation metrics and trajectory data are logged
   - Rendered video may be saved as `.mp4` (if configured)

#### Output Files

After execution, you'll find:

```
plans/
‚îú‚îÄ‚îÄ scenario_wall_01_plan.json        # High-level action sequence
‚îú‚îÄ‚îÄ scenario_wall_01_trajectory.csv   # Detailed position/velocity data
‚îî‚îÄ‚îÄ scenario_wall_01_metrics.json     # Performance metrics
```

---

### Advanced Configuration

For custom scenarios, refer to:
- **`instance_generator.py`** ‚Äî Generate new climbing scenarios with custom grip layouts
- **`angle_data_analyzer.py`** ‚Äî Analyze joint angle distributions from completed runs
- **`pruning_analyzer.py`** ‚Äî Evaluate planning efficiency and search space reduction